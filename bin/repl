#!/usr/bin/env ruby

require 'socket'
require 'json'

Thread.abort_on_exception = true

class Queue
  def initialize
    @h = {}
  end
  
  def shift type, obj
    if q=@h[type]
      if cb = q.shift
        cb.call obj['result'], obj['err']
      end
    end
  end
  
  def push type, &b
    (@h[type] ||= []) << b
    true
  end
end

class Client < TCPSocket
  def out *o
    STDOUT.puts *o
  end
  
  def process data
    return if !data or data.strip == ""

    obj = JSON.parse(data, allow_nan: true)


    if obj['status']
      queue.shift obj['status'], obj
    elsif obj['err']
      out obj['backtrace']
      out obj['info']
      raise obj['err']
    end
  end
  
  attr_reader :queue
  def run
    @queue = Queue.new
  
    Thread.new do
      loop do
        s = gets("\n")
        process s.strip if s
        flush if s
      end
    end
  end
  
  def balances *coins, market: nil, &b
    if market
      command({
        type:   "pair_balances",
        params: {
          market: market.upcase
        }
      })
     
      queue.push('pair_balances', &b)     
    elsif !coins.empty?
      command({
        type:   "balances",
        params: {
          coins: coins.map do |c| c.to_s.upcase end
        }
      })
      
          
      queue.push('balances', &b)
    else
      command({
        type:   "balances",
        params: {
        }
      })
      
          
      queue.push('balances', &b)
    end
  end
  
  def balance coin, &b
    command({
      type:   "balance",
      params: {
        coins: coin.to_s.upcase
      }
    })
      
    queue.push('balance', &b)
  end
  
  def pair_balances market, &b
    balance market: market, &b
  end
  
  def update_balances &b
    command({
      type:   'update_balances',
      params: {}
    })
    
    queue.push('update_balances', &b)    
  end
  
  def tick market=nil, &b
    command({
      type: 'tick',
      params: {
        market: market
      }
    })
    
    queue.push "tick", &b
  end
  
  def candle market=nil, &b
    command({
      type: 'candle',
      params: {
        market: market
      }
    })
    
    queue.push "candle", &b
  end  
  
  def get_order uuid, &b
    command({
      type: 'get_order',
      params: {
        uuid: uuid
      }
    })
    
    queue.push "get_order", &b
  end
  
  def order market: nil, type: nil, amount: nil, limit: nil
    command({
      type: 'order',
      params: {
        market: market,
        limit:  limit,
        amount: amount,
        type:   type
      }  
    })
    
    queue.push('order', &b)
  end
  
  def subscribe market, &b
    command({
      type: 'subscribe',
      params: {
        market: market
      }
    })
    
    queue.push('subscribe', &b)
  end
  
  def flash &b
    queue.push 'flash' do |obj|
      b.call obj
      flash &b
    end
  end
  
  def history market, periods, interval: :min, &b
    command({
      type:   'history',
      params: {
        market:   market,
        interval: interval,
        periods: periods
      }
    })
    
    queue.push 'history', &b
  end
  
  def next_candle market, &b
    command( {
      type: 'next_candle',
      params: {
        market: market
      }
    })
    
    queue.push 'next_candle', &b
  end
  
  def command obj
    puts obj.to_json
  end
  
  def self.repl ins
    class << ins
      attr_reader :c
      def connect h=nil,p=nil
        @c = Client.new((h || '0.0.0.0'), (p || 2222))
        @c.run
      end
    end  
  end
  
  def updates &b
    queue.push('tick') do |*o|
      b.call *o if b
      updates &b
    end
  end
  
  def get_ema market, periods, &b
    command( {
      type: 'get_ema',
      params: {
        market: market,
        periods: 12
      }
    })
    
    queue.push 'get_ema', &b  
  end
  
  def result obj
    raise obj['err'] if obj['err']
    obj['result']
  end
end

if __FILE__ == $0
  require 'pry'
  Client.repl self
  Pry.start
end
