#!/usr/bin/env ruby

require 'trex'
require 'trex/socket_api'
require 'grio/dsl'

require 'moving_average'

module Enumerable
  def every(n)
    (n - 1).step(self.size - 1, n).map { |i| self[i] }
  end
end

class Commands
  def perform ins, socket, req
    send req['type'], ins, socket, req
  rescue => e
    {err: "#{e}", backtrace: e.backtrace}
  end
  
  def tick ins, socket, req
    m = (req['params']['market'] || socket.active)    
    if m and ins.markets[m]        
      obj = ins.tick(m)
      obj[:status] = "tick"
    else
      obj = {status: 'active', err: "No active (valid) market."}
    end
    
    obj
  end

  def sum ins, socket, req
    avail = []
    total = []
    
    summaries = ins.summaries
    
    Trex.env[:balances].find_all do |b|
      b.amount > 0
    end.each do |b|
      if b.coin == :USDT
        avail << b.avail
        total << b.amount
        next
      end
      
      markets = summaries.find_all do |s|
        s["MarketName"].split("-")[1] == b.coin.to_s
      end.sort do |x,y|
        cr = 1
        if (base=x['MarketName'].split("-")[0]) != "USDT"
          cr = summaries.find do |s| s['MarketName'] == "USDT-#{base}" end['Last']
        end
        
        tx = x['Last'] * cr * b.amount

        cr = 1
        if (base=y['MarketName'].split("-")[0]) != "USDT"
          cr = summaries.find do |s| s['MarketName'] == "USDT-#{base}" end['Last']
        end
        
        ty = y['Last'] * cr * b.amount
        
        tx <=> ty
      end
      
      cr = 1
      if (base=markets[-1]['MarketName'].split("-")[0]) != "USDT"
        cr = summaries.find do |s| s['MarketName'] == "USDT-#{base}" end['Last']
      end
              
      total << markets[-1]['Last'] * cr * b.amount
      avail << markets[-1]['Last'] * cr * b.avail
    end
    
    t = 0
    a = 0
    
    total.each do |v| t+=v end
    avail.each do |v| a+=v end
        
    {
      status: 'sum',
      result: {
        total: t,
        avail: a
      }
    }
  end

  def candle ins, socket, req
    m   = (ins.markets[req['params']['market']] || ins.markets[socket.active])
    
    if m
      obj = {
        status: 'candle',
        result: m.chart.candle.to_h
      }
    else
      obj = {status: 'candle', err: "No active (valid) market."}
    end
  end
 
  def pair_balances ins,socket,req
    if m = (ins.markets[n=req['params']['market']] || ins.markets[socket.active])
      obj = m.get_balances
    else
      raise "Bad market: #{n}"
    end
    
  rescue => e
    {
      status: "pair_balances",
      err: "#{e}"
    }
  end

  def update_balances ins,socket,req
    ins.update_balances
    
    {
      status: "update_balances",
      result: true
    }
  rescue => e
    {
      status: "update_balances",
      err: "#{e}"
    }
  end
  
  def balances ins,socket,req
    if coins=req['params']['coins']
      h = {}
      
      coins.each do |c|
        if bal=Trex.env[:balances].find do |b|
          b.coin.to_s == c.upcase
        end
          h[c.upcase] = bal.to_h
        end
      end
      
      {
        status: 'balances',
        result: h
      }
    else
      {
        status: 'balances',
        result: Trex.env[:balances].map do |b| b.to_h end
      }
    end
  rescue => e
    {
      status: 'balances',
      err:    "#{e}"
    }
  end

  def active ins, socket, req
    if m = req['params']['market']
      socket.active = m
      
      if ins.markets[socket.active]
        obj = {status: 'active', result: true}
      else
        obj = {status: 'active', err: "Bad market name."}
      end
    else
      obj = {status: "active?", result: socket.active}
    end
  end
    
  def order ins, socket, req
    params = req['params']
    m      = params['market'] || socket.active
    type   = params['type']
    
    p [:order, m, type]
      
    if !ins.markets[m] or !type
      obj = {
        status: 'order',
        err:    "bad values for order.",
        info:   {
          market: m,
          type:   type,
        }
      }
    else
      rate, amt = params['limit'], params['amount']
      obj = ins.markets[m].order type, limit: rate, amount: amt
    end
  rescue => e
    {
      status: 'order',
      err: "#{e}"
    }
  end
  
  def history ins, socket, req
    o = req['params']
    
    market   = o['market']
    
    unless periods = o['periods']
      return({
        status: "history",
        err: "must specifiy periods",
        info: {
          market: market,
          periods: periods
        }
      })
    end
    
    if m=ins.markets[market]
      {
        status: 'history',
        result: {
          rates: m.chart.candle_data(periods).map do |t| t.to_h end,
        }
      }
    else
      {
        status: "history",
        err: "No market for: #{market}.",
        info: {
          market: market
        }
      }
    end
  end

  def get_ema ins, socket, req
    raise "must specifiy periods" unless periods = req['params']['periods']
    raise "must specifiy market"  unless m       = req['params']['market']
    
    offset = req['params']['offset'] ||= 0
    
    raise "No Market: #{m}" unless market = ins.markets[m]

    {
      status: 'get_ema',
      result: market.chart.ema(periods, offset)
    }
  rescue => e
    {
      status: 'get_ema',
      err: "#{e}",
    }
  end
  
  def subscribe ins, socket, req
    ins.ensure_market m=req['params']['market'], socket
    
    unless socket.markets.index(m)
      socket.markets << m
    end
    
    {
      status: 'async',
      result: 'subscribe'
    }
    
  rescue => e
    obj = {
      status: 'subscribe',
      err: "#{e}",
      info: req['params']['market']
    }
  end  
  
  def next_candle ins, socket, req
    raise "no market param" unless m = req['params']['market']
    raise "no subsribed market: #{m}" unless ins.markets[m]
    
    ins.markets[m].chart.on_candle(socket)
    {
      status: 'async',
      result: 'next_candle',
      info:   {
        market: m
      }
    }
  rescue => e
    {
      status: 'next_candle',
      err:    "#{e}",
      info:   {
        market: m
      }
    }
  end
  
  def get_order ins, socket, req
    raise "No UUID" unless uuid=req['params']['uuid']
    
    if o=Trex.env[:account].get_order(uuid)
      {
        status: 'get_order',
        result: o.to_h
      }
    else
      {
        status: 'get_order',
        result: nil
      }
    end
  end  
end

class ChartBuffer
  attr_reader :market, :interval
  def initialize market, interval=:min
    case interval
    when :hour
      @interval = 60
    when :min
      @interval = 1
    when :day
      @interval = 1*60*24
    end
    
    @data      = Trex.get_ticks(market)
    @on_candle = []
  end
  
  attr_reader :candle, :last
  def on_candle socket
    @on_candle << socket
  end
  
  def update r, close=false
    return @candle if !r
    
    if !@candle 
      @candle = Trex::Market::Tick.new
      while socket = @on_candle.shift        
        socket.put_result('next_candle', {
          current: candle.to_h,
          last:    last.to_h
        })
      end
    end
    
    @candle.close = r
    @candle.open  = r if !@candle.open     
    @candle.high  = r if !@candle.high or (r > @candle.high)
    @candle.low   = r if !@candle.low  or (r < @candle.low)
    
    if close
      @data.shift
      @data << @candle
      @last = @candle
      @candle = nil
      update r
    end
    
    @candle
  end
  
  def ma periods, type, offset=0, field: :close
    candle_data(periods, offset, field).send type
  end

  def ema periods, offset=0
    ma periods, :ema, offset  
  end

  def sma periods
    ma periods, :sma
  end

  def smma periods
    ma periods, :smma
  end
  
  def ema12
    ema 12
  end
  
  def ema26
    ema 26
  end
  
  def candle_data periods, offset=0, field=nil
    a = @data.every(interval)[(-1*(periods+offset))..(-1-offset)]
    if field
      a.map do |c|
        c[field] 
      end
    else
      a
    end
  end
  
  def highs periods
    candle_data(periods, :high)
  end 

  def lows periods
    candle_data(periods, :low)
  end 
  
  def chart
  
  end
end

class Market
  attr_reader :name, :balances, :account, :base, :coin
  attr_accessor :chart, :book, :flash_level
  def initialize name
    @name        = name
    
    @base, @coin = name.split("-").map do |c| c.upcase.to_sym end
    
    @chart       = ChartBuffer.new(name) 
    @flash_level = 0
    
    @account = Trex.env[:account]
  end
  
  def balances
    {
      base: Trex.env[:balances].find do |b| b.coin == base end,
      coin: Trex.env[:balances].find do |b| b.coin == coin end
    }
  end
  
  def get_balances    
    {
      status: 'pair_balances',
      result: {
        market: name,
        base: balances[:base].to_h,
        coin: balances[:coin].to_h
      }
    }
  rescue => e
    {
      err: "#{e}",
      status: "pair_balances"
    }
  end
  
  def market_order_rate amt, type
    rate = book.rate_at amt, type
  end
  
  def market_order_amount type
    if type == :bid
      amt = book.amt_for balances[:base].avail, type
    else
      amt = balances[:coin].avail
    end
  end
  
  def market_order_rates
    {
      bid: {
        amount: amt=market_order_amount(:bid),
        rate:   r=market_order_rate(amt, :bid),
        price:  amt*r,
      },
      ask: {
        amount: amt=market_order_amount(:ask),
        rate:   r=market_order_rate(amt, :ask),
        price:  amt*r,
      }
    }  
  end
  
  def get_market_order_rates
    {
      status: 'get_market_order_rates',
      result: market_order_rates
    }
  rescue => e
    {
      err: "#{e}",
      status: 'get_market_order_rates'
    }
  end
  
  def order type, limit: nil, amount: nil
    uuid = nil
    
    type=type.to_sym
    
    t,a,r = type, nil, nil
    
    case type
    when :market_sell
      obj = market_order_rates[:ask]
      t = :sell
      a = obj[:amount]
      r = obj[:rate]
    when :market_buy
      obj = market_order_rates[:bid]
      t = :buy
      a = balances[:base][:avail]
      r = obj[:rate]
      p [t,a,r]    
    when :sell
      a = (amount || balances[:coin].avail)
      r = limit || book.diff
    when :buy
      a = (amount || balances[:coin].avail)
      r = limit || book.diff
    end
    
    [t, name, a, r]
    
    uuid = account.send(t, name, a, r)
    
    if uuid
      adj_balance t, a, r
    end
    
    {
      status: 'order',
      result: {
        uuid: uuid
      }
    }
  rescue => e
    {
      err: "#{e}",
      status: 'order',
      info: {
        type:   type,
        limit:  limit,
        amount: amount
      }
    }
  end
  
  def adj_balance t, a, r
    if t == :buy
      balances[:base].avail  -= a
      balances[:base].amount -= a
      balances[:coin].avail  += ((a*0.9975)/r)
      balances[:coin].amount += ((a*0.9975)/r)
    elsif t == :sell
      balances[:coin].avail  -= a
      balances[:coin].amount -= a
      balances[:base].avail  += (a*r*0.9975)   
      balances[:base].amount += (a*r*0.9975)      
    end
  end
end

module Client
  attr_accessor :active, :markets
  attr_reader :sells, :buys
  
  def subscribed_to? name
    @markets.index(name)
  end

  def put_result status, result
    puts JSON.dump({
      status: status,
      result: result
    })
  rescue
    close
  end
  
  def on_err e
    STDOUT.puts "#{self} disconnected."
    false
  end
end

class << self
  attr_reader :markets, :books, :clients
  
  def header
    puts `clear`
    puts 'BTC-AEON'
  end
  
  def view market
    @market = market
  end
  
  def tick m=@market.name, period=nil
    market = markets[m]
    b      = market.book
    
    {
      status: 'tick',
      result: {
        market:       market.name,
    
        balances:     {
                        base: market.balances[:base].to_h,
                        coin: market.balances[:coin].to_h
                      },
    
        bid:          b.high_bid,
        ask:          b.low_ask,
        last:         b.last,
        diff:         b.diff,
    
        market_order: market.market_order_rates,
      }
    }
  rescue => e
    {
      err: "#{e}",
      backtrace: e.backtrace,
      status: 'tick'
    }
  end

  def parse_data socket,data
    return if socket.closed? or !clients.index(socket)
    
    req = {}
    begin
      req = JSON.parse(data.strip)     
    rescue => e
      socket.puts JSON.dump({err: 'JSON Parse Error', info: data})
      return
    end
    
    obj = @commands.perform self, socket, req    
    
    socket.puts JSON.dump(obj)     
  rescue => e
    begin
      socket.puts JSON.dump({err: "#{e}", backtrace: e.backtrace})
    rescue => e
      socket.close
      clients.delete socket
    end
  end
  
  def ensure_market name, socket=nil
    puts "populating..."
    
    begin
      markets[name] ||= Market.new(name)
    
      if socket
        socket.puts(JSON.dump(obj = {
          status: 'subscribe',
          result: {
            market: name
          }
        }))
      end
    rescue => e
      if socket
        socket.puts(JSON.dump(obj = {
          status: 'subscribe',
          err: "#{e}",
          info: {
            market: name
          }
        }))
      end
    end
    
    Trex.socket.order_books(name) do |book, name, state|
      if markets[name] and !markets[name].book
        markets[name].book = book
      
        book.bids.clear
        book.asks.clear
        book.trades.clear
        
        bk = Trex.book name, "both" 
        
        bk["buy"].each do |b|
          b.keys.each do |k| b[:"#{k}"]= b[k] end
          book.bids[b[:Rate]] = Trex::SocketAPI::Entry.from_obj(:bid, b)
        end
        
        bk["sell"].each do |b|
          b.keys.each do |k| b[:"#{k}"]= b[k] end
          book.asks[b[:Rate]] = Trex::SocketAPI::Entry.from_obj(:ask, b)
        end
      else
        chart = markets[name].chart
        l     = book.last
        
        if l          
          chart.update l
        end
        
        obj = tick(name)
        msg = obj.to_json(allow_nan: true)      

        clients.each do |c|
          begin
            c.puts msg if c.subscribed_to?(name)
          rescue
            clients.delete c
            c.close
          end
        end
      end
      
      true
    end    
  end
  
  def serve!
    grio.socket.serve "0.0.0.0", 2222 do |socket|
      socket.extend Client
      socket.active  = @market.name if @market
      socket.markets = []
      
      clients << socket
      
      begin        
        socket.listen do |data|
          parse_data socket, data
        end
      rescue
        clients.delete socket
        socket.close
      end
    end   
  end
  
  def run
    @markets  = {}
    @commands = Commands.new
    
    serve!       
    
    Trex.env[:balances] = Trex.env[:account].balances
    
    ensure_market "USDT-BTC"
    
    @market = markets["USDT-BTC"]
    
    @clients = []
    
    Trex.run do
      puts "Trex::Mainloop."
      Trex.init
  
      connect_ws
      
      Trex.timeout 500 do
        if Trex.socket.singleton.closed?
          connect_ws
          sleep 1
        end
        
        true
      end
      
      Trex.timeout 2000 do
        update_balances
        
        true
      end
      
      Trex.timeout 60000 do
        markets.each_pair do |k,v|
          next unless book = markets[k].book 
          v.chart.update book.last, true
        end
        
        true
      end
    end
  end
  
  def summaries
    Trex.summaries struct: false
  end
  
  def update_balances
    Trex.env[:balances] = Trex.env[:account].balances 
  end
  
  def connect_ws
    puts "WebSocket.connect"
    markets.each_pair do |k,v|
      v.book = nil
    end
    
    Trex.socket.singleton.on :close do
      puts :closed
      sleep 1
      connect_ws
    end 
  end
  
rescue => IOError
  clients.find_all do |c| c.closed? end.each do |c| clients.delete c end
end


run
