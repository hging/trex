#!/usr/bin/env ruby

require 'trex'
require 'trex/socket_api'
require 'grio/dsl'

require 'moving_average'

module Enumerable
  def every(n)
    (n - 1).step(self.size - 1, n).map { |i| self[i] }
  end
end

class Commands
  def perform ins, socket, req
    send req['type'], ins, socket, req
  rescue => e
    {err: "#{e}", backtrace: e.backtrace}
  end
  
  def tick ins, socket, req
    m = (req['params']['market'] || socket.active)    
    if m and ins.markets[m]        
      obj = ins.tick(m)
      obj[:status] = "tick"
    else
      obj = {status: 'active', err: "No active (valid) market."}
    end
    
    obj
  end

  def candle ins, socket, req
    m   = (ins.markets[req['params']['market']] || ins.markets[socket.active])
    
    if m
      obj = {
        status: 'candle',
        result: m.chart.candle.to_h
      }
    else
      obj = {status: 'candle', err: "No active (valid) market."}
    end
  end
 
  def balance ins,socket,req
    m   = (ins.markets[req['params']['market']] || ins.markets[socket.active])

    if m
      obj = m.get_balances
    else
      obj = {status: 'balance', err: "No active (valid) market."}
    end
  end

  def active ins, socket, req
    if m = req['params']['market']
      socket.active = m
      
      if ins.markets[socket.active]
        obj = {status: 'active', result: true}
      else
        obj = {status: 'active', err: "Bad market name."}
      end
    else
      obj = {status: "active?", result: socket.active}
    end
  end
    
  def order ins, socket, req
    params = req['params']
    m      = params['market'] || socket.active
    type   = params['type']
      
    if !ins.markets[m] or !type
      obj = {
        status: 'order',
        err:    "bad values for order.",
        info:   {
          market: m,
          type:   t,
        }
      }
    else
      rate, amt = params['limit'], params['amount']
      obj = ins.markets[m].order type, limit: rate, amount: amt
    end
  end
    
  def status ins, socket, req
    obj = {
      status: 'status',
      result: o=Trex::Order.get(Trex.env[:account], uuid=req['params']['uuid']).to_h,
      info: {
        uuid: uuid
      }
    }
  end
  
  def history ins, socket, req
    o = req['params']
    
    market   = o['market']
    interval = (o['interval'] || :min).to_sym
    
    unless [:day, :min, :hour].index(interval)
      return({
        status: "history",
        err: "bad value for interval",
        info: {
          market: market,
          interval: interval
        }
      })
    end    
    
    case interval
    when :min
      interval = 1
    when :hour
      interval = 60
    when :day
      interval = 60*24
    end
    
    unless periods = o['periods']
      return({
        status: "history",
        err: "must specifiy periods",
        info: {
          market: market,
          periods: periods
        }
      })
    end
    
    if m=ins.markets[market]
      all    = m.chart.candle_data(0).every(interval)[(-1*(periods+26))..-1].map do |c| c.close end
      p interval
      p periods
      p (-1*(periods+26))

      p all.length
      pos    = 26
  
      ema12=[]
      ema26=[]
  
    
      e12  = all[14..-1]
      e26  = all[0..-1]
      rates = all[26..-1]
      c = 0
      
      rates.map do |q|
        ema12 << e12.ema(11,12)
        ema26 << e26.ema(25,26)
        e12.shift
        e26.shift
        c+=1
        if c % 2 == 0
        pos += 1
      
        pos+1 > all.length-1 ? (next) : (true)     
        end
      end
            
      
      {
        status: 'history',
        result: {
          rates: m.chart.candle_data(0).every(interval)[(-1*periods)..-1].map do |t| t.to_h end,
          ema12: ema12,
          ema26: ema26
        }
      }
    else
      {
        status: "history",
        err: "No market for: #{market}.",
        info: {
          market: market
        }
      }
    end
  end
  
  def subscribe ins, socket, req
    ins.ensure_market m=req['params']['market'], socket
    
    unless socket.markets.index(m)
      socket.markets << m
    end
    
    {
      status: 'async',
      result: 'subscribe'
    }
    
  rescue => e
    obj = {
      status: 'subscribe',
      err: "#{e}",
      info: req['params']['market']
    }
  end  
end

class ChartBuffer
  attr_reader :market, :interval
  def initialize market, interval=:min
    case interval
    when :hour
      @interval = 60
    when :min
      @interval = 1
    when :day
      @interval = 1*60*24
    end
    
    @data = Trex.get_ticks(market)
  end
  
  attr_reader :candle
  def update r, close=false
    return @candle if !r
    
    @candle ||= Trex::Market::Tick.new
    
    @candle.close = r
    @candle.open  = r if !@candle.open     
    @candle.high  = r if !@candle.high or (r > @candle.high)
    @candle.low   = r if !@candle.low  or (r < @candle.low)
    
    if close
      @data.shift
      @data << @candle
      @candle = nil
      update r
    end
    
    @candle
  end
  
  def ma periods, type
    candle_data(periods).map do |c|
      (c.open + c.close + c.high + c.low) / 4.0
    end.send type
  end

  def ema periods
    ma periods, :ema  
  end

  def sma periods
    ma periods, :sma
  end

  def smma periods
    ma periods, :smma
  end
  
  def ema12
    ema 12
  end
  
  def ema26
    ema 26
  end
  
  def candle_data periods, type=nil
    a = @data.every(interval)[(-1*periods)..-1]
    if type
      a.map do |c|
        c[type] 
      end
    else
      a
    end
  end
  
  def highs periods
    candle_data(periods, :high)
  end 

  def lows periods
    candle_data(periods, :low)
  end 
end

class Market
  attr_reader :name, :balances, :account, :base, :coin
  attr_accessor :chart, :book, :flash_level
  def initialize name
    @name        = name
    
    @base, @coin = name.split("-").map do |c| c.upcase.to_sym end
    
    @chart       = ChartBuffer.new(name) 
    @flash_level = 0
    
    @account = Trex.env[:account]
    
    update_balances
  end
  
  def update_balances
    @balances = {
      base: account.balance(base),
      coin: account.balance(coin)
    }
    
    {
      status: 'update_balances',
      result: @balances.to_h
    }  
  rescue => e
    {
      err: "#{e}",
      status: 'update_balances'
    }
  end
  
  def get_balances    
    {
      status: 'balance',
      result: {
        market: name,
        base: @balances[:base].to_h,
        coin: @balances[:coin].to_h
      }
    }
  rescue => e
    {
      err: "#{e}",
      status: "balance"
    }
  end
  
  def market_order_rate amt, type
    rate = book.rate_at amt, type
  end
  
  def market_order_amount type
    if type == :bid
      amt = book.amt_for balances[:base].avail, type
    else
      amt = balances[:coin].avail
    end
  end
  
  def market_order_rates
    {
      bid: {
        amount: amt=market_order_amount(:bid),
        rate:   r=market_order_rate(amt, :bid),
        price:  amt*r,
      },
      ask: {
        amount: amt=market_order_amount(:ask),
        rate:   r=market_order_rate(amt, :ask),
        price:  amt*r,
      }
    }  
  end
  
  def get_market_order_rates
    {
      status: 'get_market_order_rates',
      result: market_order_rates
    }
  rescue => e
    {
      err: "#{e}",
      status: 'get_market_order_rates'
    }
  end
  
  def order type, limit: nil, amount: nil
    uuid = nil
    t,a,r = type, nil, nil
    
    case type
    when :market_sell
      obj = market_order_rates[:ask]
      t = :sell
      a = obj[:amount]
      r = obj[:rate]
    when :market_buy
      obj = market_order_rates[:bid]
      t = :buy
      a = obj[:amount]
      r = obj[:rate]    
    when :sell
      a = (amount || balances[:coin].avail)
      r = limit || book.diff
    when :buy
      a = (amount || balances[:coin].avail)
      r = limit || book.diff
    end
    
    order = account.send(t, name, a, r)
    
    {
      status: 'order',
      result: order.to_h
    }
  rescue => e
    {
      err: "#{e}",
      status: 'order',
      info: {
        type:   type,
        limit:  limit,
        amount: amount
      }
    }
  end
end

module Client
  attr_accessor :active, :markets
  attr_reader :sells, :buys
  
  def subscribed_to? name
    @markets.index(name)
  end
  
  def on_err e
    STDOUT.puts "#{self} disconnected."
    false
  end
end

class << self
  attr_reader :markets, :books, :clients
  
  def header
    puts `clear`
    puts 'BTC-AEON'
  end
  
  def view market
    @market = market
  end
  
  def tick m=@market.name, period=nil
    market = markets[m]
    b      = market.book
    
    {
      status: 'tick',
      result: {
        market:       market.name,
        balances:     {
                        base: market.balances[:base].to_h,
                        coin: market.balances[:coin].to_h
                      },
        bid:          b.high_bid,
        ask:          b.low_ask,
        last:         b.last,
        diff:         b.diff,
        ema12:        market.chart.ema12,
        ema26:        market.chart.ema26,
        market_order: market.market_order_rates,
        flash_level:  market.flash_level
      }
    }
  rescue => e
    {
      err: "#{e}",
      backtrace: e.backtrace,
      status: 'tick'
    }
  end

  def parse_data socket,data
    return if socket.closed? or !clients.index(socket)
    
    req = {}
    begin
      req = JSON.parse(data.strip)     
    rescue => e
      socket.puts JSON.dump({err: 'JSON Parse Error', info: data})
      return
    end
    
    obj = @commands.perform self, socket, req    
    
    socket.puts JSON.dump(obj)     
  rescue => e
    begin
      socket.puts JSON.dump({err: "#{e}", backtrace: e.backtrace})
    rescue => e
      socket.close
      clients.delete socket
    end
  end
  
  def ensure_market name, socket=nil
    puts "populating..."
    
    begin
      markets[name] ||= Market.new(name)
    
      if socket
        socket.puts(JSON.dump(obj = {
          status: 'subscribe',
          result: {
            market: name
          }
        }))
      end
    rescue => e
      if socket
        socket.puts(JSON.dump(obj = {
          status: 'subscribe',
          err: "#{e}",
          info: {
            market: name
          }
        }))
      end
    end
    
    Trex.socket.order_books(name) do |book, name, state|
      if !markets[name].book
        markets[name].book = book
      
        book.bids.clear
        book.asks.clear
        book.trades.clear
        
        bk = Trex.book name, "both" 
        
        bk["buy"].each do |b|
          b.keys.each do |k| b[:"#{k}"]= b[k] end
          book.bids[b[:Rate]] = Trex::SocketAPI::Entry.from_obj(:bid, b)
        end
        
        bk["sell"].each do |b|
          b.keys.each do |k| b[:"#{k}"]= b[k] end
          book.asks[b[:Rate]] = Trex::SocketAPI::Entry.from_obj(:ask, b)
        end
      else
        chart = markets[name].chart
        l     = book.last
        
        if l
          ema = chart.ema 3
          # flash price drops
          if l < ema*0.70
            markets[name].flash_level = 30
          elsif l < ema*0.85
            markets[name].flash_level = 15
          elsif l < ema*0.90
            markets[name].flash_level = 10
          elsif l < ema*0.95
            markets[name].flash_level = 5
          elsif l < ema*0.98
            markets[name].flash_level = 2  
          elsif l < ema*0.99
            markets[name].flash_level = 1              
          else
            markets[name].flash_level = 0
          end
          
          if (lvl=markets[name].flash_level) > 0
            msg = {
              status: 'flash',
              result: {
                market: name,
                level:  lvl,
                ema: ema,
                tick: tick(name)['result'],
                type:  'flash'
              }
            }.to_json(allow_nan: true)
              
            clients.each do |c|
              begin
                c.puts msg if c.subscribed_to?(name)
              rescue
                clients.delete c
                c.close
              end
            end
          end
          
          chart.update l
        end
        
        obj = tick(name)
        msg = obj.to_json(allow_nan: true)      

        clients.each do |c|
          begin
            c.puts msg if c.subscribed_to?(name)
          rescue
            clients.delete c
            c.close
          end
        end
      end
      
      true
    end    
  end
  
  def serve!
    grio.socket.serve "0.0.0.0", 2222 do |socket|
      socket.extend Client
      socket.active  = @market.name
      socket.markets = []
      
      clients << socket
      
      begin        
        socket.listen do |data|
          parse_data socket, data
        end
      rescue
        clients.delete socket
        socket.close
      end
    end   
  end
  
  def run
    @markets  = {}
    @commands = Commands.new
    
    serve!       
    
    ensure_market "USDT-BTC"
    
    @market = markets["USDT-BTC"]
    
    @clients = []
    
    Trex.run do
      puts "Trex::Mainloop."
      Trex.init
  
      connect_ws
      
      Trex.idle do
        if Trex.socket.singleton.closed?
          connect_ws
          sleep 1
        end
      end
      
      Trex.timeout 60000 do
        markets.each_pair do |k,v|
          next unless book = markets[k].book 
          v.chart.update book.last, true
        end
      end
    end
  end
  
  def connect_ws
    markets.each_pair do |k,v|
      v.book = nil
    end
    
    Trex.socket.singleton.on :close do
      puts :closed
      sleep 1
      connect_ws
    end 
  end
  
rescue => IOError
  clients.find_all do |c| c.closed? end.each do |c| clients.delete c end
end


run
