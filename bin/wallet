#!/usr/bin/env ruby

require 'trex'
require 'grio/dsl'

if ARGV.index "--socket"
  require 'trex/socket_api' 
  require 'readline'
end

Trex.init

raise unless account=Trex.env[:account]

def get_balances account,watching=[]
  return(account.balances.find_all do |bal|
    bal.amount > 0 or watching.index(bal.coin.to_s.upcase.to_sym)
  end)
end

class Colourize
  FG_NORMAL = -1
  BG_NORMAL = -1
  
  COLORS = [
    0,1,2,3,4,5,6,7,9
  ]
  
  def self.generate str, fcol=FG_NORMAL, bcol=BG_NORMAL
    bcol = 9 if bcol == -1
    bcol = bcol + 40 if bcol <= 9
    
    fcol = 9 if fcol == -1
    fcol = fcol + 30 if fcol <= 9    
    
    "\e[#{fcol};#{bcol}m"+str+"\e[0m"  
  end
  
  def self.case str, truth, aset, bset = [-1,-1], &b
    if truth
      return generate str,*aset
    end
    
    generate str, *bset
  end
end

class String
  def colourize? truth, aset, bset=[-1,-1]
    Colourize.case self, truth, aset, bset
  end
  
  def colourize fg,bg=-1
    Colourize.generate self,fg,bg
  end
end


def print_balances balances
  puts ("COIN".ljust(6)+"      Amount".ljust(16)+"       Avail".ljust(16)+"        BTC".ljust(16)+"          USD".ljust(10)+"     Rate BTC          Rate USD").colourize(7)
  puts "-"*100
  tu=0
  tb=0

  balances.each do |bal|
    tb += (b = bal.btc)
    tu += (u = bal.usd)
  
    puts "#{bal.coin.to_s.ljust(5)} #{bal.amount.trex_s.rjust(16)} #{bal.avail.trex_s.rjust(16).colourize?(bal.amount > bal.avail,[-1,1],[-1,-1])} #{(b).trex_s.rjust(16)} #{(u).trex_s(3).rjust(10)}   #{(rt=bal.rate).trex_s(10).colourize?(rt > Trex.candle("BTC-#{bal.coin}").prev, [0, 2], [0, 1])} #{(Trex.btc_usd * rt).trex_s(3).rjust(10)}" 
  end
  puts "".ljust(100,"-")
  puts "BTC:".colourize(7)+" #{tb.trex_s.rjust(16)} #{"USD:".colourize(7)} #{tu.trex_s(3).rjust(10)}"
end

print_balances balances=get_balances(account,watching=[])

if ARGV.index "--socket"
  obl      = balances.length
  print msg="Messages:".colourize(7,4)+"\n"
  print "TRXSH:> "
  Trex.run do
    Trex.stream do |s|#.summaries(*balances.map do |bal| "BTC-#{bal.coin}" end) do
      Trex.socket.flash_watch(*balances.map do |bal| "BTC-#{bal.coin}" end) do end
    
      Trex.idle do
        grio.read_nonblock do |line|
          cmd, *args = line.split(" ")
          
          case cmd
          when 'watch'
            coin = args[0].to_s.upcase.to_sym
          
            balances << account.balance(coin) unless balances.find do |bal| bal.coin == coin end
            watching << coin                  unless watching.index(coin)
          when 'buy' 
            market = "BTC-#{args[0].upcase}"
            rate   = args[1] || "diff"
            amount = args[2] || -1
            msg="Messages:".colourize(7,4)+ " BUY Order"+`ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=#{market} --rate=#{rate} --amount=#{amount} --buy`
            
          when 'sell' 
            market = "BTC-#{args[0].upcase}"
            rate   = args[1] || Trex.env[:rates][market]
            amount = args[2] || -1
            msg="Messages:".colourize(7,4)+" SELL Order"+`ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=#{market} --rate=#{rate} --amount=#{amount} --sell`            
          end
          
          print "\033[1A"          
          print "\r#{"TRXSH:> "}#{(" "*line.length)}"
          line.length.times do 
            print "\b"
          end
        end
        
        true
      end

      Trex.timeout 10000 do
        balances = get_balances account,watching
        obl      = balances.length
        true
      end
    
      Trex.timeout 100 do
        print "\033[s" 
        (obl+5).times do |i|
          print "\033[1A"          
          print "\r"
        end

        print_balances balances
        print msg
        print "TRXSH:> "
        print "\033[u" unless obl != balances.length
        obl = balances.length
        true
      end
    end
  end
end
