#!/usr/bin/env ruby

require 'trex'
require 'grio/dsl'

if ARGV.index "--socket"
  require 'trex/socket_api' 
  require 'readline'
end


require 'readline'

class Screen
  attr_accessor :lines, :columns, :prompt, :on_input_cb
  def initialize prompt: "", columns: 100
    Thread.new do
      while line = Readline.readline(@prompt=prompt, true)
        if cb=@on_input_cb
          cb.call line
        end
      end 
    end

    @lines   = 0
    @columns = columns
  end
  
  def on_input &b
    @on_input_cb = b
  end
  
  def add_line line
    _puts line
    self.lines += 1
  end
  
  alias :_print :print
  alias :_puts :puts
  
  def clear
    clear_line -2 if prompt
      
    lines.times do
      clear_line
    end
    @lines = 0
  end

  def update &b
    clear
    b.call self
    append "#{@prompt} "+Readline.line_buffer.to_s    
  end
  
  def append s
    _print s
  end
  
  def clear_line idx=0
    idx = lines-1 if idx == -1
    
    _print "\033[#{idx+1}A" if idx >= 0
    _print "\r"
    _print " "*columns
    _print "\b"*columns
  end
  
  def replace idx, value
    save
    clear_line idx
    _print value
    restore
  end
  
  def save 
    print "\033[s"
  end
  
  def restore
    print "\033[u"
  end
  
  def []= idx, value
    return replace idx,value if idx < lines
    add_line value
  end
  
  def puts s
    add_line s
  end
  
  def print s
    append s
  end
end

$screen = Screen.new prompt: "TRXSH>: "


Trex.init

raise unless account=Trex.env[:account]

def get_balances account,watching=[]
  return(account.balances.find_all do |bal|
    bal.amount > 0 or watching.index(bal.coin.to_s.upcase.to_sym)
  end)
end

class Colourize
  FG_NORMAL = -1
  BG_NORMAL = -1
  
  COLORS = [
    0,1,2,3,4,5,6,7,9
  ]
  
  def self.generate str, fcol=FG_NORMAL, bcol=BG_NORMAL
    bcol = 9 if bcol == -1
    bcol = bcol + 40 if bcol <= 9
    
    fcol = 9 if fcol == -1
    fcol = fcol + 30 if fcol <= 9    
    
    "\e[#{fcol};#{bcol}m"+str+"\e[0m"  
  end
  
  def self.case str, truth, aset, bset = [-1,-1], &b
    if truth
      return generate str,*aset
    end
    
    generate str, *bset
  end
end

class String
  def colourize? truth, aset, bset=[-1,-1]
    Colourize.case self, truth, aset, bset
  end
  
  def colourize fg,bg=-1
    Colourize.generate self,fg,bg
  end
end

$message = "Messages:".colourize(7,4)
def message str=""
  $screen[-1] = $message = "Messages:".colourize(7,4)+" #{str}"
end

def btc_usd bal
  return (u = bal.usd) unless $btc_rate_override
  return $btc_rate_override.to_f*bal.btc
end

def print_balances balances
  $screen.puts ("COIN".ljust(6)+"      Amount".ljust(17)+"       Avail".ljust(16)+"        BTC".ljust(16)+"          USD".ljust(10)+"     Rate BTC          Rate USD").colourize(7)
  $screen.puts "-"*100
  
  tu=0
  tb=0

  balances.each do |bal|
    tb += (b = bal.btc)*0.9975
    tu += u=btc_usd(bal)*0.9975
  
    $screen.puts "#{bal.coin.to_s.ljust(5)} #{bal.amount.trex_s.rjust(17)} #{bal.avail.trex_s.rjust(16).colourize?(bal.amount.to_f > bal.avail.to_f,[-1,1],[-1,-1])} #{(b).trex_s.rjust(16)} #{(u).trex_s(3).rjust(10)}   #{(rt=bal.rate).trex_s(10).colourize?(rt > Trex.candle("BTC-#{bal.coin}").prev, [0, 2], [0, 1])} #{(Trex.btc_usd * rt).trex_s(3).rjust(10)}" 
  end
  
  $screen.puts "".ljust(100,"-")
  $screen.puts "BTC:".colourize(7)+" #{tb.trex_s.rjust(16)} #{"USD:".colourize(7)} #{tu.trex_s(3).rjust(10)}"
  $screen.puts $message.to_s
end

print_balances balances=get_balances(account,watching=[])

if ARGV.index "--socket"
  lo=nil
  Trex.run do
    Trex.stream do |s|#.summaries(*balances.map do |bal| "BTC-#{bal.coin}" end) do
      Trex.socket.flash_watch(*balances.map do |bal| "BTC-#{bal.coin}" end) do end
    
      $screen.on_input do |line|
          cmd, *args = line.split(" ")
          
          case cmd
          when 'watch'
            coin = args[0].to_s.upcase.to_sym
          
            balances << account.balance(coin) unless balances.find do |bal| bal.coin == coin end
            watching << coin                  unless watching.index(coin)
          when "cancel"
            if !args[0] and lo and lo["uuid"]
              `ruby bin/order --cancel='#{lo["uuid"]}' #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end}`
            elsif args[0]
              `ruby bin/order --cancel='#{args[0]}' #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end}`
            end
          when 'buy' 
            market = "BTC-#{args[0].upcase}"
            rate   = args[1] || "diff"
            amount = args[2] || -1
            message "BUY Order "+lo=`ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=#{market} --rate=#{rate} --amount=#{amount} --buy`
            begin
              lo = JSON.parse(lo)
            rescue => e;message e.to_s; end
          when 'sell' 
            market = "BTC-#{args[0].upcase}"
            rate   = args[1] || Trex.env[:rates][market]
            amount = args[2] || -1
            message "SELL Order "+lo=`ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=#{market} --rate=#{rate} --amount=#{amount} --sell`            
            begin
              lo = JSON.parse(lo.strip)
            rescue => e ;message e.to_s; end
          when "addr"
            coin = args[0]
            message "#{coin.upcase} Deposit Address: #{account.address(coin)}"
          when "eval"
            message "#{`ruby -e "p(#{args.join(' ')})"`}"
          when "rate"
            $btc_rate_override = args[0]
          end
          
          $screen.clear_line -2
          $screen.clear_line
      end

      Trex.timeout 10000 do
        balances = get_balances account,watching
        true
      end
    
      Trex.timeout 100 do
        $screen.update do
          print_balances balances
        end
        true
      end
    end
  end
end
