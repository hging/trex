#!/usr/bin/env ruby

require 'trex'
require 'grio/dsl'

if ARGV.index "--socket"
  require 'trex/socket_api' 
  require 'readline'
end


require 'readline'

class Screen
  attr_accessor :lines, :columns, :prompt, :on_input_cb
  def initialize prompt: "", columns: 100
    Thread.new do
      while true
        line = Readline.readline(@prompt=prompt, true)

        clear_line 0 if line
        
        if cb=@on_feed_cb
          cb.call line if line
        end
        
        if !line and cb=@on_nil_feed_cb
          cb.call self
        end
        
        if line == "" and cb=@on_blank_feed_cb
          cb.call self
        end
      end 
    end

    @lines   = 0
    @columns = columns
  end
  
  def on_feed &b
    @on_feed_cb = b
  end
  
  def on_blank_feed &b
    @on_blank_feed_cb = b
  end
  
  def on_nil_feed &b
    @on_nil_feed_cb = b
  end
  
  def add_line line
    _puts line
    self.lines += 1
  end
  
  alias :_print :print
  alias :_puts :puts
  
  def clear
    clear_line -2 if prompt
      
    lines.times do
      clear_line
    end
    @lines = 0
  end

  def update &b
    clear
    b.call self
    append "#{@prompt} "+(buff=Readline.line_buffer.to_s)
    point = Readline.point
    (buff.length-point).times do
      print "\b"
    end
  end
  
  def append s
    _print s
  end
  
  def clear_line idx=0
    idx = lines-1 if idx == -1
    
    _print "\033[#{idx+1}A" if idx >= 0
    _print "\r"
    _print " "*columns
    _print "\b"*columns
  end
  
  def replace idx, value
    save
    clear_line idx
    _print value
    restore
  end
  
  def save 
    print "\033[s"
  end
  
  def restore
    print "\033[u"
  end
  
  def []= idx, value
    return replace idx,value if idx < lines
    add_line value
  end
  
  def puts s
    add_line s
  end
  
  def print s
    append s
  end
end

class Colourize
  FG_NORMAL = -1
  BG_NORMAL = -1
  
  COLORS = [
    0,1,2,3,4,5,6,7,9
  ]
  
  def self.generate str, fcol=FG_NORMAL, bcol=BG_NORMAL, bold: false
    bcol = 9 if bcol == -1
    bcol = bcol + 40 if bcol <= 9
    
    fcol = 9 if fcol == -1
    fcol = fcol + 30 if fcol <= 9    
    
    bcol = 1 if bold
    
    "\e[#{fcol};#{bcol}m"+str+"\e[0m"  
  end
  
  def self.case str, truth, aset, bset = [-1,-1], &b
    if truth
      return generate str,*aset
    end
    
    generate str, *bset
  end
end

class String
  def colourize? truth, aset, bset=[-1,-1]
    Colourize.case self, truth, aset, bset
  end
  
  def colourize fg,bg=-1, bold: false
    Colourize.generate self,fg,bg, bold: bold
  end
end

$screen = Screen.new prompt: "TRXSH>: ".colourize(-1,bold: true)


Trex.init

raise unless account=Trex.env[:account]

def get_balances account,watching=[]
  return(account.balances.find_all do |bal|
    bal.amount > 0 or watching.index(bal.coin.to_s.upcase.to_sym)
  end)
end


$msg_line = 0
$msg_buff = ""

def message msg=$msg_buff, bool = false
  $msg_buff = msg
  $msg_line = 0 unless bool
  a=msg.to_s.split("\n")
  n = a.length > 0 ? $msg_line+1 : 0
  $message  = "Messages:".colourize(7,4)+" "+(a)[$msg_line].to_s+" [#{n} / #{a.length}]"
end
message ""

$screen.on_blank_feed do
  if ($msg_line += 1) >= (len=$msg_buff.split("\n").length)
    $msg_line = len-1
  end

  message $msg_buff, true
end

$screen.on_nil_feed do
  if ($msg_line -= 1) < 0
    $msg_line = 0
  end

  message $msg_buff, true
end

$gdax = {}

def update_gdax
  $enable_gdax = true
  Thread.new do
    begin
    loop do
      [:LTC, :ETH, :BTC].each do |coin|
        obj = JSON.parse(open("https://api.gdax.com/products/#{coin}-USD/ticker").read)
        $gdax[coin] = obj["price"].to_f
      end
      sleep 1.1
    end
    rescue => e
      message e.to_s
    end
  end
end

update_gdax if ARGV.index("--gdax-rates") or ARGV.index("--enable-gdax-rates")
$btc_rate_override = "gdax" if ARGV.index("--gdax-rates")


def usd bal = nil
  if !bal
    return $gdax[:BTC] if $gdax[:BTC] and $btc_rate_override == "gdax"
    return  $btc_rate_override.to_f if $btc_rate_override and  $btc_rate_override != "gdax"
    return Trex.btc_usd  
  end
  
  if $btc_rate_override == "gdax" and $gdax[bal.coin]
    return $gdax[bal.coin] * bal.btc if $gdax[bal.coin]
    return bal.usd
  end
  
  return $gdax[:BTC]*bal.btc if $btc_rate_override == "gdax" and $gdax[:BTC]
  
  return (u = bal.usd) unless $btc_rate_override
  
  return $btc_rate_override.to_f*bal.btc
end

def print_balances balances
  $screen.puts ("COIN".ljust(6)+"      Amount".ljust(17)+"       Avail".ljust(16)+"        BTC".ljust(16)+"          USD".ljust(10)+"     Rate BTC          Rate USD").colourize(-1, bold: true)
  $screen.puts "-"*100
  
  tu=0
  tb=0

  balances.each do |bal|
    tb += (b = bal.btc)*0.9975
    tu += u=usd(bal)*0.9975
  
    $screen.puts "#{bal.coin.to_s.ljust(5).colourize(-1, bold: true)} #{bal.amount.trex_s.rjust(17)} #{bal.avail.trex_s.rjust(16).colourize?(bal.amount.to_f > bal.avail.to_f,[-1,1],[-1,-1])} #{(b).trex_s.rjust(16)} #{(u).trex_s(3).rjust(10)}   #{(rt=bal.rate).trex_s(10).colourize?(rt > Trex.candle("BTC-#{bal.coin}").prev, [0, 2], [0, 1])} #{(usd() * rt).trex_s(3).rjust(10)}" 
  end
  
  gdax = ""
  if $enable_gdax
    ltc = (tb / Trex.btc(:LTC,1)) * $gdax[:LTC].to_f
    eth = (tb / Trex.btc(:ETH,1)) * $gdax[:ETH].to_f
    btc = tb                      * $gdax[:BTC].to_f
  end
  gdax = "["+"GDAX - BTC: ".colourize(-1,bold: true)+btc.trex_s(3)+" ETH: ".colourize(-1,bold: true)+eth.trex_s(3)+" LTC: ".colourize(-1,bold: true)+ltc.trex_s(3)+"]"
  
  $screen.puts "".ljust(100,"-")
  $screen.puts "BTC:".colourize(-1, bold: true)+" #{tb.trex_s.rjust(16)} #{"USD:".colourize(-1, bold: true)} #{tu.trex_s(3).rjust(10)} #{$enable_gdax ? gdax : ""}"
  $screen.puts "API_RATE: #{Trex::JSONApi.rate.trex_s(3)}, "+$message.to_s
end

$wallets = {}
if ARGV.find do |a| a=~/\-\-wallets\=(.*)/ end
  obj = {}
  
  begin
    obj = JSON.parse(File.open(File.expand_path($1)).read)
  rescue => e
    message(e.to_s)
  end
  
  $wallets = obj
end

balances = []; watching = []
$screen.update do
  print_balances balances=get_balances(account,watching=[])
end

if ARGV.index "--socket"
  lo=nil
  oa=[]
  Trex.run do
    Trex.stream do |s|#.summaries(*balances.map do |bal| "BTC-#{bal.coin}" end) do
      Trex.socket.flash_watch(*balances.map do |bal| "BTC-#{bal.coin}" end) do end
    
      $screen.on_feed do |line|
          cmd, *args = line.split(" ")
          
          case cmd
          when 'watch'
            coin = args[0].to_s.upcase.to_sym
          
            balances << account.balance(coin) unless balances.find do |bal| bal.coin == coin end
            watching << coin                  unless watching.index(coin)
          when "cancel"
            if !args[0] and lo and lo["uuid"]
              `ruby bin/order --cancel='#{lo["uuid"]}' #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end}`
            elsif args[0] == "all"
              `ruby bin/order --cancel=all #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end}`
            elsif args[0] == "market"
              `ruby bin/order --cancel=true --market='#{args[1]}' #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end}`
            elsif args[0] =~ /^([0-9]+)/ and !oa.empty?
              `ruby bin/order --cancel='#{oa[$1.to_i].uuid}' #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end}`
            end
          when 'buy' 
            market = "BTC-#{args[0].upcase}"
            rate   = args[1] || "diff"
            amount = args[2] || -1
            message "BUY Order "+lo=`ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=#{market} --rate=#{rate} --amount=#{amount} --buy`
            begin
              lo = JSON.parse(lo)
            rescue => e;message e.to_s; end
          when 'sell' 
            market = "BTC-#{args[0].upcase}"
            rate   = args[1] || "diff"
            amount = args[2] || -1
            message "SELL Order "+lo=`ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=#{market} --rate=#{rate} --amount=#{amount} --sell`            
            begin
              lo = JSON.parse(lo.strip)
            rescue => e ;message e.to_s; end
          when "addr"
            coin = args[0]
            message "#{coin.upcase} Deposit Address: #{account.address(coin)}"
          when "eval"
            message "#{`ruby -e "p(#{args.join(' ')})"`}"
          when "rate"
            if args[0] == "gdax"
              update_gdax unless $enable_gdax
              message "Rate: Using GDAX for USD conversion" 
            end
            message "Rate: using bittrex market data" if !args[0]
            $btc_rate_override = args[0]
          when "uuid"
            if !args[0] and lo and uuid=lo["uuid"]
              message "Laster Order UUID: #{uuid}"
            elsif !oa.empty? and idx=args[0]
              o = oa[idx.to_i]
              message("UUID: #{o.uuid}")
            else
              message "UUID: No Orders this Session"
            end
          when "open"
            if args[0].to_s =~ /^([0-9]+)/
              o = oa[idx=$1.to_i]
              
              if !o
                message("No order")
                next
              end
              
              message([
                "Index: #{idx}", "Market: #{o.market}", "Rate: #{o.limit}",
                "Amount: #{o.quantity}",
                "Type: #{o.type}"
              ].join(", "))
              next
            end
          
            oa = account.orders.find_all do |o|
              args[0] ? o.market == args[0] : true
            end
            
            idx=-1
            a=oa.map do |o|
              [
                "Index: #{idx+=1}",
                "Market: #{o.market}",
                "Rate: #{o.limit}",
                "Amount: #{o.quantity}",
                "Type: #{o.type}"
              ].join(", ")
            end
            message(a.empty? ? "No Orders" : a.join("\n"))
          when "nonzero"
            balances.find_all do |bal| watching.index bal.coin end.each do |bal| balances.delete bal end
            watching = []
          when "withdrawals"
            begin
              message(account.withdrawals(args[0] ? args[0].upcase.to_sym : nil).map do |w|
                "#{w.currency} #{w.amount} #{w.txid} #{w.pending}"
              end.join("\n"))
            rescue => e
              message(e.to_s)
            end
          when "withdraw"
            group = $wallets[args[0]]
            coin  = args[1].upcase.to_s.to_sym
            if args[1] and addr = group[coin.to_s]
              if !args[2]
                begin
                  message(account.withdraw!(coin, addr)["uuid"])
                rescue => e
                  message(e.to_s)
                end
              elsif amt=args[2]
                begin
                  amt = Float(amt)
                  message(account.withdraw(coin, amt , addr)["uuid"]) 
                rescue => e
                  message(e.to_s)
                end
              end
            elsif coin
              begin
                amt = Float(args[2])
                account.withdraw(coin, amt , args[0]) 
              rescue => e
                message(e.to_s)
              end
            end
          when "stash"
            target = args[0] || :USDT
          
            get_balances(account,[]).each do |bal|
              next if bal.coin == :BTC
              next if bal.coin == target
              
              market = "BTC-#{bal.coin}"
              `ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=#{market} --rate=diff --amount=-1 --sell`
            end
            
            Trex.idle do
              list = balances.map do |bal| bal.coin end.sort
              if list == [:BTC, target].sort or list == [:BTC]
                `ruby bin/order #{ARGV.find do |a| a =~ /\-\-account\-file\=/ end} --market=USDT-BTC --rate=diff --amount=-1 --sell`
                next false
              else
                next true
              end
            end
          end
      end

      Trex.timeout 10000 do
        balances = get_balances account,watching
        true
      end
    
      Trex.timeout 100 do
        $screen.update do
          print_balances balances
        end
        true
      end
    end
  end
end
